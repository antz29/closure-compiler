#summary Frequently asked questions.

<wiki:toc max_depth="3" />

Let us know if you have one that you'd like to add!

== Unexpected Output ==

===The compiler crashes with `Exception in thread "main" java.lang.UnsupportedClassVersionError: Bad version number in .class file`===

Closure Compiler requires [http://java.sun.com/javase/6/ Java 6]. This is Java's way of telling you to upgrade your version of Java.

===I get a "Trailing comma is not legal" error. But it works on Firefox!===

But not on Internet Explorer. 

On IE, the object literal `{key: value,}` is an error. 

IE will parse the array literal `[1,]` successfully, but differently.

{{{
[1,].length
=> 1 (on Firefox)
=> 2 (on IE)
}}}

This difference is highly likely to lead to bugs, so we just forbid it outright.

===I get "Unsupported syntax" errors. But it works on Firefox!===

Firefox has done a lot of cool innovations since JavaScript 1.5. Closure Compiler does not support anything that is not backwards-compatible with JS 1.5. This includes:

  * [https://developer.mozilla.org/En/Core_JavaScript_1.5_Guide/Constants The `const` keyword]
  * [https://developer.mozilla.org/En/Core_JavaScript_1.5_Guide:Creating_New_Objects:Defining_Getters_and_Setters Getters and setters]
  * [https://developer.mozilla.org/en/New_in_javascript_1.7#Destructuring_assignment Destructuring assignments]

===Closure Compiler inlined all my strings, which made my code size bigger. Why did it do that?===

Most people compare code size by looking at two uncompressed JavaScript files. But that's a misleading way to look at code size, because your JavaScript files should not be served uncompressed. It should be served with [http://developer.yahoo.net/blog/archives/2007/07/high_performanc_3.html gzip compression].

Closure Compiler assumes that you are using gzip compression. If you do not, you should: gzipping your code is one of the most effective and easiest optimizations that you can possibly do. [http://en.wikipedia.org/wiki/Gzip The gzip algorithm] works by trying to alias sequences of bytes in an optimal way. Aliasing strings manually almost always makes the compressed code size bigger, because it subverts gzip's own algorithm for aliasing. So Closure Compiler will (almost) always inline your strings when it can, because that will make your compressed code smaller.

==Using Closure Compiler==

===How do I make sure my variables don't collide with other scripts on the page?===

Closure Compiler has an `--output_wrapper` flag for exactly this purpose. Invoking it as `--output_wrapper "(function() {%output%})();"` will wrap your code in an anonymous function, so that it doesn't pollute the global scope.

===How do I call Closure Compiler from the Java API?===

There's no official tutorial yet for the Java API. There's a short code snippet on [http://blog.bolinfest.com/2009/11/calling-closure-compiler-from-java.html this blog] that, in our opinion, gives a nice 1-minute demo on how to do this.

If you're looking at Closure Compiler's source code, [http://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java AbstractCommandLineRunner.java] and [http://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/javascript/jscomp/CommandLineRunner.java CommandLineRunner.java] do the heavy-lifting of translating command-line flags into Java API calls, so you could find some inspiration there. For a comprehensive reference on the Java API, we check our [http://closure-compiler.googlecode.com/svn/trunk/javadoc/index.html JavaDoc] into SVN, for easy browsing. It will always reflect the version at trunk.

Notice that Closure Compiler uses threads. Many Java implementations (like [http://code.google.com/appengine/ Google App Engine], for example) do not support threads, so you may need to call the [http://closure-compiler.googlecode.com/svn/trunk/javadoc/com/google/javascript/jscomp/Compiler.html#disableThreads() disableThreads] method.

===How do I write an externs file?===

Externs files define APIs outside (or "external") to your code. the externs file should define all external variables, types, and properties that you intend to interact with. For example, Closure Compiler doesn't know about the browser APIs for interacting with the window and the DOM. Instead, we ship Closure Compiler with a default set of externs files that defines the browser APIs. This default set is probably the best example of how to write an externs file. As you can see, it defines global variables like `window`, types like `Range`, and properties like `Window.prototype.alert`.

http://code.google.com/p/closure-compiler/source/browse/#svn/trunk/externs

If you need an externs file for a common API (like the Google Maps API), first try asking on [http://groups.google.com/group/closure-compiler-discuss closure-compiler-discuss] whether someone has already written one. You can find more information about externs files in [http://code.google.com/closure/compiler/docs/api-tutorial3.html#externs the official documentation].

== Design of Closure Compiler ==

===Is there a specification for the JSDoc type language?===

The Closure Compiler type language tries to adhere as closely as possible to the [http://wiki.ecmascript.org/doku.php?id=spec:spec EcmaScript 4 draft spec], which contains a rigorous grammar for the type language, and a description of the intended semantics.

We also have a more informal tutorial on [http://code.google.com/closure/compiler/docs/js-for-compiler.html#types how to write type annotations].

If you look at Closure Library, you may see some type annotations that do not fit the grammar exactly as specified, but get parsed correctly anyway. This is usually intentional. The EcmaScript 4 draft was in flux as we were implementing it, and so there are some legacy type syntaxes that we still support. (This mostly involves the order of certain operators, and the operator used for union types).

===Can you add alternative syntax X to your JSDoc type language?===

If X adds a way to do something that wasn't possible before, then you should propose your idea on [http://groups.google.com/group/closure-compiler-discuss closure-compiler-discuss].

If X is already possible some other way, then 99% of the time, the answer is no. 

There are many tools that need to parse our JSDoc type language. When you add a new syntax, that means all those tools need to be updated. The documentation needs to be updated, and every JavaScript developer needs to be taught that the syntaxes are equivalent. It becomes harder to write new tools, because the language is now more complicated.

If this new syntax doesn't add any real value, then we really can't justify that cost.

===I'm writing a Firefox extension. It only needs to work on the bleeding-edge version of Firefox. I don't care if it doesn't work in other browsers. Could we add a `--platform=FIREFOX` flag that lets me use the snazzy JavaScript features introduced in  [https://developer.mozilla.org/en/New_in_javascript_1.7 JavaScript 1.7]?===

In general, no. There are two reasons for this.

The first is that we're lazy. In the past, Closure Compiler passes were mostly written by Google engineers in their volunteer time. The development cycle went like, "Hey! My app is running slow, but I could speed it up if I added this optimization. I can write it in an afternoon and then go back to my full-time job." Most developers are not experts on JavaScript. So it was pretty important to us that it was easy for developers to write new passes without understanding the two-dozen variants of JavaScript.

The second is that we really like sharing code. Suppose I write a JavaScript class for my Firefox extension that uses Firefox-only keywords. A couple months later, my friend Kushal likes it, and wants to use it in his web app. His web app has to work on Internet Explorer. But trying to untangle all the [https://developer.mozilla.org/En/Core_JavaScript_1.5_Guide:Creating_New_Objects:Defining_Getters_and_Setters getters and setters] takes way too long. He gives up when he realizes that it's easier for him to rewrite the code from scratch. This makes both of us unhappy. We find that everyone's happier if code works cross-browser, and it's easy to share.